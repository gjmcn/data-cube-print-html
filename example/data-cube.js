!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.dc=e()}(this,function(){"use strict";function t(t,e){return t(e={exports:{}},e.exports),e.exports}var e=t(function(t){{const e={dimName:["row","column","page"],shortDimName:["row","col","page"],lettersArray:["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"],timeUnits:new Map([["year","FullYear"],["month","Month"],["day","Date"],["hour","Hours"],["minute","Minutes"],["second","Seconds"],["milli","Milliseconds"]]),copyArray:t=>{const e=t.length,r=new Array(e);for(let n=0;n<e;n++)r[n]=t[n];return r},equalArray:(t,e)=>{var r=t.length;if(r!==e.length)return!1;for(var n=0;n<r;n++)if(t[n]!==e[n])return!1;return!0},equalArrayOfArray:(t,r)=>{if(!Array.isArray(t)||!Array.isArray(r))return!1;const n=t.length;if(n!==r.length)return!1;for(let o=0;o<n;o++){if(!Array.isArray(t[o])||!Array.isArray(r[o]))return!1;if(!e.equalArray(t[o],r[o]))return!1}return!0},copyMap:t=>{const e=new Map;for(let[r,n]of t.entries())e.set(r,n);return e},equalMap:(t,e)=>{if(t.size!==e.size)return!1;const r=e.entries();for(let[e,n]of t.entries()){let[t,o]=r.next().value;if(e!==t||n!==o)return!1}return!0},toMap:(...t)=>{const e=t.length;if(e%2!=0)throw Error("even number of arguments expected");const r=new Map;for(let n=0;n<e;n+=2)r.set(t[n],t[n+1]);if(r.size!==e/2)throw Error("duplicate key");return r},keyMap:t=>{const e=t.length,r=new Map;for(let n=0;n<e;n++){let e=t[n];if(void 0===e||null===e)throw Error(`invalid key: ${e}`);r.set(e,n)}if(r.size!==e)throw Error("duplicate key");return r},simpleRange:t=>{t=r.nonNegInt(t);for(var e=new Array(t),n=0;n<t;n++)e[n]=n;return e},shuffle:t=>{t=r.posInt(t);const n=e.simpleRange(t);for(let e=t-1;e>0;e--){let t=Math.floor(Math.random()*(e+1)),r=n[e];n[e]=n[t],n[t]=r}return n},fill:(t,e)=>{const r=t.length;for(let n=0;n<r;n++)t[n]=e;return t},fillEW:(t,e)=>{const r=t.length;if(e.length!==r)throw Error("shape mismatch");for(let n=0;n<r;n++)t[n]=e[n];return t},isSingle:t=>!Array.isArray(t)||1===t.length,toArray:t=>Array.isArray(t)?t:[t],polarize:t=>Array.isArray(t)?1===t.length?[t[0],!0]:[t,!1]:[t,!0],def:(t,e)=>void 0===t?e:t,addArrayMethod:(t,e)=>{if(t in Array.prototype)throw Error(t+" is already a property of Array.prototype");Object.defineProperty(Array.prototype,t,{value:e,configurable:!0,enumerable:!1,writable:!0})},ensureKey:t=>{t._k||(t._k=new Array(3))},ensureLabel:t=>{t._l||(t._l=new Array(3))},copyKey:(t,r,n)=>{if(t._k)for(let o=0;o<3;o++)o!==n&&t._k[o]&&(e.ensureKey(r),r._k[o]=e.copyMap(t._k[o]))},copyLabel:(t,r,n)=>{if(t._l)for(let o=0;o<3;o++)o!==n&&t._l[o]&&(e.ensureLabel(r),r._l[o]=t._l[o])},skeleton:(t,r,n)=>{const o=[];return o._s=e.copyArray(t._s),e.copyKey(t,o,r),e.copyLabel(t,o,n),o},nni:(t,e)=>{if(!Number.isInteger(t))throw Error("integer expected");if(t>=e||t<-e)throw Error("index out of bounds");return t<0?t+e:t},rangeKey:(t,e,r)=>{const n=new Array(r.size);let o=null===t||void 0===t?1:0;const i=null!==e&&void 0!==e;let s=0;for(let l of r.keys())if(o){if(n[s++]=l,i&&l===e){o=2;break}}else if(l===t){if(n[s++]=l,i&&t===e){o=2;break}o=1}if(0===o)throw Error("start key does not exist");if(i&&1===o)throw Error("end-key does not exist or is before start-key");return n.length=s,n},firstKey:(t,e)=>{const r=new Array(t);let n=0;for(let o of e.keys()){if(n===t)break;r[n++]=o}return r.length=n,r},rangeInd:(t,e)=>{if(e<t)throw Error("end less than start");const r=new Array(e-t+1);let n=0;for(let o=t;o<=e;o++)r[n++]=o;return r},indInd:(t,r)=>{const n=t.length,o=new Array(n);for(let i=0;i<n;i++)o[i]=e.nni(t[i],r);return o},keyInd:(t,e)=>{const r=t.length,n=new Array(r);for(let o=0;o<r;o++){let r=e.get(t[o]);if(void 0===r)throw Error("key does not exist");n[o]=r}return n},comparison:t=>{if(void 0!==t&&null!==t){if("asc"===t)return(t,e)=>t-e;if("desc"===t)return(t,e)=>e-t;if("function"==typeof t)return t;throw Error("invalid argument")}},sortInPlace:(t,r)=>t.sort(e.comparison(r)),sortIndex:(t,r)=>{const n=e.simpleRange(t.length);if(void 0===r||null===r)return n.sort((e,r)=>""+t[e]>""+t[r]?1:""+t[r]>""+t[e]?-1:0);if("asc"===r)return n.sort((e,r)=>t[e]-t[r]);if("desc"===r)return n.sort((e,r)=>t[r]-t[e]);if("function"==typeof r)return n.sort((e,n)=>r(t[e],t[n]));throw Error("invalid argument")},sortRank:(t,r)=>{const n=e.sortIndex(t,r),o=t.length;if(0===o)return[];if(1===o)return[0];const i=new Array(o);let s=e.comparison(r);void 0===s&&(s=((t,e)=>""+t>""+e?1:""+e>""+t?-1:0));let l=n[0];i[l]=0;for(let e=1;e<o;e++){let r=n[e];i[r]=0===s(t[l],t[r])?i[l]:e,l=r}return i},timer:t=>{const e=process.hrtime();t();const r=process.hrtime(e);return Math.round((1e9*r[0]+r[1])/1e6)}};{const t=e.lettersArray,r=new Map;for(let e=0;e<t.length;e++)r.set(t[e],e);e.lettersMap=r}const r={int:t=>{if(!Number.isInteger(t))throw Error("integer expected");return t},nonNegInt:t=>{if(!Number.isInteger(t)||t<0)throw Error("non-negative integer expected");return t},posInt:t=>{if(!Number.isInteger(t)||t<=0)throw Error("positive integer expected");return t},nonNegFin:t=>{if(!Number.isFinite(t)||t<0)throw Error("non-negative finite number expected");return t},fin:t=>{if(!Number.isFinite(t))throw Error("finite number expected");return t},number:t=>{if("number"!=typeof t)throw Error("number expected");return t},dim:t=>{if(void 0===(t=r.single(t)))return 0;if(0!==t&&1!==t&&2!==t)throw Error("invalid dimension");return t},single:t=>{if(Array.isArray(t)){if(1!==t.length)throw Error("singleton expected");return t[0]}return t},func:t=>{if("function"!=typeof t)throw Error("function expected");return t},argRange:(t,e,r)=>{const n=t.length;if(n<e)throw Error("too few arguments");if(n>r)throw Error("too many arguments");return n}};e.assert=r,t.exports=e}});return t(function(t){{const r=e,{assert:n,fill:o,fillEW:i,addArrayMethod:s,keyMap:l,isSingle:h,polarize:f,def:u,toArray:a,copyArray:c,copyMap:g,ensureKey:d,ensureLabel:p,nni:m,copyKey:y,copyLabel:b,skeleton:_,sortInPlace:w,sortIndex:E,sortRank:v,rangeInd:k,keyInd:A,indInd:C}=r;s("_helper",r),["_data_cube","_s","_k","_l"].forEach(t=>{if(t in Array.prototype)throw Error(t+" is a property of Array.prototype")});{const t={};["copyWithin","fill","pop","push","reverse","shift","sort","splice","unshift"].forEach(e=>{t[e]=Array.prototype[e],delete Array.prototype[e],s(e,function(){return t[e].apply(this.toArray(),arguments)})})}s("toCube",function(){return this._data_cube||(this._data_cube=!0,this._s=[this.length,1,1]),this}),s("toArray",function(){return this._data_cube&&(delete this._data_cube,delete this._s,this._k&&delete this._k,this._l&&delete this._l),this}),s("compare",function(t,e){if(this.toCube(),e=u(n.single(e),!0),this===t)return this;let o;if(o=e?t=>{throw Error(t)}:()=>!1,!Array.isArray(t))return o("cube compared to non-array");const i=this.length;if(i!==t.length)return o("number of entries not equal");for(let e=0;e<i;e++)if(this[e]!==t[e])return o(`entries at vector index ${e} not equal`);if(t._data_cube){if(!r.equalArray(this._s,t._s))return o("shape not equal");const e=this._k,n=t._k;if(e){if(!n)return o("keys-indices");for(let t=0;t<3;t++)if(e[t]){if(!n[t])return o(`keys-indices, ${r.dimName[t]}s`);if(!r.equalMap(e[t],n[t]))return o(`${r.dimName[t]} keys not equal`)}else if(n[t])return o("indices-keys")}else if(n)return o("indices-keys");const i=this._l,s=t._l;if(i){if(!s)return o("labels not equal or not used on same dimensions");if(!r.equalArray(i,s))return o("labels not equal or not used on same dimensions")}else if(s)return o("labels not equal or not used on same dimensions")}else{if(1!==this._s[1]||1!==this._s[2])return o("shape not equal");if(this._k)return o("keys-indices");if(this._l)return o("labels not equal or not used on same dimensions")}return this}),s("cube",function(t){if(this.length>3)throw Error("shape cannot have more than 3 entries");const e=void 0===this[0]?1:n.nonNegInt(this[0]),r=void 0===this[1]?1:n.nonNegInt(this[1]),s=void 0===this[2]?1:n.nonNegInt(this[2]),l=new Array(e*r*s);l._data_cube=!0,l._s=[e,r,s];var[t,h]=f(t);return void 0!==t&&(h?o:i)(l,t),l}),s("rand",function(t){t=n.single(t);const e=this.cube(),r=e.length;if(void 0!==t){const o=n.posInt(+t)+1;for(let t=0;t<r;t++)e[t]=Math.floor(Math.random()*o)}else for(let t=0;t<r;t++)e[t]=Math.random();return e}),s("normal",function(t,e){const r=()=>{let t,e,r;for(;;)if((r=(t=2*Math.random()-1)*t+(e=2*Math.random()-1)*e)>0&&r<1)return t*Math.sqrt(-2*Math.log(r)/r)};if(t=+u(n.single(t),0),(e=+u(n.single(e),1))<=0)throw Error("positive number expected (standard deviation)");const o=this.cube(),i=o.length;for(let n=0;n<i;n++)o[n]=r()*e+t;return o}),s("seq",function(t,e){if(2!==this.length)throw Error("2-entry array expected");const[o,i]=this;if(void 0===(t=n.single(t)))t=1;else if(t=+t,!Number.isFinite(t)||0===t)throw Error("finite, non-zero jump expected");const s=(t,e,r)=>{if(t<e&&r<0||t>e&&r>0)throw new Error("stepping in wrong direction")};let l;if(void 0!==(e=n.single(e))){if(!Number.isInteger(t))throw Error("date range: integer jump expected");"week"===e&&(t*=7,e="day");const n=r.timeUnits.get(e);if(!n)throw Error("invalid time unit");const h=t=>{const e=typeof t;let r;if("string"===e||"number"===e)r=new Date(t);else{if(!(t instanceof Date))throw Error("date, string or number expected");r=new Date(t.getTime())}if(!Number.isFinite(r.getTime()))throw Error("invalid start or end date");return r},f="get"+n,u="set"+n,a=h(o),c=h(i),g=a.getTime(),d=c.getTime();if(g===d)l=[a];else{s(g,d,t),l=[];let e=0,r=a,n=g<d?()=>r.getTime()<=d:()=>r.getTime()>=d;for(;n();)l[e++]=r,(r=new Date(r.getTime()))[u](r[f]()+t)}}else if("number"==typeof o)if(n.fin(o),n.fin(i),o===i)l=[o];else{s(o,i,t);const e=Math.floor((Math.abs(i-o)+1e-15)/Math.abs(t))+1;l=new Array(e);for(let r=0;r<e;r++)l[r]=o+r*t}else{if("string"!=typeof o)throw Error("arguments not consistent with number, string or date range");{if(!Number.isInteger(t))throw Error("string range: integer jump expected");if("string"!=typeof i)throw Error("string expected");const e=r.lettersMap.get(o),n=r.lettersMap.get(i);if(void 0===e||void 0===n)throw Error("string range: start or end invalid");if(e===n)l=[o];else{s(e,n,t);const o=r.lettersArray,i=Math.floor((n-e)/t)+1;l=new Array(i);for(let r=0;r<i;r++)l[r]=o[e+r*t]}}}return l}),s("lin",function(t,e){if(2!==this.length)throw Error("2-entry array expected");const r=n.fin(+this[0]),i=n.fin(+this[1]);if(t=+u(n.single(t),10),!Number.isInteger(t))throw Error("number of points: integer expected");if(t<2)throw Error("number of points must be at least 2");if("point"!==(e=u(n.single(e),"point"))&&"step"!==e)throw Error("'point' or 'step' expected");let s,l;if(r===i)s=0,l=o(new Array(t),r);else if(s=(i-r)/(t-1),(l=new Array(t))[0]=r,l[t-1]=i,t>2)for(let e=1;e<t-1;e++)l[e]=r+e*s;return"step"===e?[l,s]:l}),s("grid",function(t,e){if(t=a(t),"value"!==(e=u(n.single(e),"value"))&&"index"!==e&&"both"!==e)throw Error("'value', 'index' or 'both' expected");const r=this.length,o=t.length,i=r*o;let s;if("value"===e||"index"===e){let n;if(s=[i,2].cube(),"value"===e)for(n=0;n<i;n++)s[n]=this[n%r];else for(n=0;n<i;n++)s[n]=n%r;for(let i=0;i<o;i++)if("value"===e)for(let e=0;e<r;e++)s[n++]=t[i];else for(let t=0;t<r;t++)s[n++]=i}else{let e;for(s=[i,4].cube(),e=0;e<i;e++)s[e]=e%r;for(let t=0;t<i;t++,e++)s[e]=this[e%r];for(let t=0;t<o;t++)for(let n=0;n<r;n++)s[e++]=t;for(let n=0;n<o;n++)for(let o=0;o<r;o++)s[e++]=t[n]}return s}),s("shape",function(){return this.toCube(),c(this._s)}),s("$shape",function(t){this.toCube();var[t,e]=f(t);let r=1,o=1,i=1;const s=0===this.length;if(void 0===t)r=this.length;else if(e)if(0===(r=n.nonNegInt(t))){if(!s)throw Error("number of entries cannot change")}else o=s?0:n.nonNegInt(this.length/r);else if(2===t.length)if((r=n.nonNegInt(t[0]))*(o=n.nonNegInt(t[1]))==0){if(!s)throw Error("number of entries cannot change")}else i=s?0:n.nonNegInt(this.length/(r*o));else{if(3!==t.length)throw Error("shape must have 1-3 entries");if((r=n.nonNegInt(t[0]))*(o=n.nonNegInt(t[1]))*(i=n.nonNegInt(t[2]))!==this.length)throw Error("number of entries cannot change")}return this._s[0]=r,this._s[1]=o,this._s[2]=i,this._k&&delete this._k,this._l&&delete this._l,this}),s("n",function(t){return this.toCube(),t=n.dim(t),this._s[t]}),s("$squeeze",function(){this.toCube();const t=this._s.map(t=>1===t?"1":"n").join("");let e;const r=t=>{const r=this[t];this[t]=[r[e[0]],r[e[1]],r[e[2]]]};return"n1n"===t?e=[0,2,1]:"1nn"===t?e=[1,2,0]:"1n1"===t?e=[1,0,2]:"11n"===t&&(e=[2,0,1]),e&&(r("_s"),this._k&&r("_k"),this._l&&r("_l")),this}),s("tp",function(t){this.toCube();var[t,e]=f(t);if(e){if(void 0!==t)throw Error("invalid permutation");t=[1,0,2]}else{if(3!==t.length)throw Error("invalid permutation");t=t.map(t=>+t);for(let e=0;e<3;e++)if(!t.includes(e))throw Error("invalid permutation")}const{_s:r,_k:n,_l:o}=this,i=r[t[0]],s=r[t[1]],l=r[t[2]],h=[i,s,l].cube(),u=[1,this._s[0],this._s[0]*this._s[1]].vec(t);let a=0;for(let t=0;t<l;t++){let e=t*u[2];for(let t=0;t<s;t++){let r=t*u[1];for(let t=0;t<i;t++)h[a++]=this[t*u[0]+r+e]}}if(n){d(h);for(let e=0;e<3;e++)n[t[e]]&&(h._k[e]=g(n[t[e]]))}if(o){p(h);for(let e=0;e<3;e++)o[t[e]]&&(h._l[e]=o[t[e]])}return h}),s("label",function(t){return this.toCube(),t=n.dim(t),this._l&&this._l[t]||null}),s("$label",function(t,e){if(this.toCube(),t=n.dim(t),void 0===(e=n.single(e))||null===e){const e=this._l;e&&e[t]&&(e[t]=void 0,e[0]||e[1]||e[2]||delete this._l)}else{if(""===(e=""+e))throw Error("label cannot be empty string");p(this),this._l[t]=e}return this}),s("key",function(t){if(this.toCube(),t=n.dim(t),this._k){const e=this._k[t];if(e)return[...e.keys()]}return null}),s("$key",function(t,e){if(this.toCube(),t=n.dim(t),1!==(e=a(e)).length||void 0!==e[0]&&null!==e[0]){const r=l(e);if(this._s[t]!==r.size)throw Error("shape mismatch");d(this),this._k[t]=r}else{const e=this._k;e&&e[t]&&(e[t]=void 0,e[0]||e[1]||e[2]||delete this._k)}return this}),s("$strip",function(){return this.toCube(),delete this._k,delete this._l,this}),s("copy",function(t){if("full"!==(t=u(n.single(t),"full"))&&"core"!==t&&"shell"!==t&&"array"!==t)throw Error("'full', 'core', 'shell' or 'array' expected");if("array"===t)return c(this);const e="shell"===t?new Array(this.length):c(this);if(e.toCube(),this._data_cube&&(e._s[0]=this._s[0],e._s[1]=this._s[1],e._s[2]=this._s[2],"core"!==t&&(this._l&&(p(e),e._l[0]=this._l[0],e._l[1]=this._l[1],e._l[2]=this._l[2]),this._k))){d(e);for(let t=0;t<3;t++)this._k[t]&&(e._k[t]=g(this._k[t]))}return e}),s("hasKey",function(t,e){this.toCube(),t=n.dim(t),e=n.single(e);const r=this._k,o=!(!r||!r[t]);return void 0===e?o:o&&r[t].has(e)}),s("ent",function(t){return this.toCube(),this[m(n.single(t),this.length)]}),s("$ent",function(t,e){return this.toCube(),this[m(n.single(t),this.length)]=n.single(e),this});{const t=(t,e,r)=>void 0===r||null===r?0:t._k&&t._k[e]?n.number(t._k[e].get(r)):m(r,t._s[e]),e=(e,r,o,i)=>t(e,0,n.single(r))+t(e,1,n.single(o))*e._s[0]+t(e,2,n.single(i))*e._s[0]*e._s[1];s("at",function(t,r,n){if(this.toCube(),0===this.length)throw Error("cube has no entries");return this[e(this,t,r,n)]}),s("$at",function(t,r,o,i){if(this.toCube(),0===this.length)throw Error("cube has no entries");return this[e(this,t,r,o)]=n.single(i),this})}s("vec",function(t){this.toCube();var[t,e]=f(t);const r=this.length;if(e)return void 0===t||null===t?c(this):[this[m(t,r)]];const n=t.length,o=new Array(n);for(let e=0;e<n;e++)o[e]=this[m(t[e],r)];return o}),s("$vec",function(t,e){this.toCube();const r=this.length;var[t,n]=f(t),[e,s]=f(e);if(n)if(void 0===t||null===t)(s?o:i)(this,e);else{if(!s)throw Error("shape mismatch");this[m(t,r)]=e}else{const n=t.length,o=new Array(n);for(let e=0;e<n;e++)o[e]=m(t[e],r);if(s)for(let t=0;t<n;t++)this[o[t]]=e;else{if(e.length!==n)throw Error("shape mismatch");for(let t=0;t<n;t++)this[o[t]]=e[t]}}return this}),s("vecInd",function(t,e,r){this.toCube();const n=this._s,o=[1,n[0],n[0]*n[1]];let i,s=0;for(let l=0;l<3;l++){let h,[u,a]=f(0===l?t:1===l?e:r),c=this._k&&this._k[l];if(a){if(0===n[l])throw Error(`${c?"key":"index"} does not exist`);if(void 0===u||null===u)continue;if(c){if(void 0===(h=c.get(u)))throw Error("key does not exist")}else h=m(u,n[l]);s+=h*o[l]}else{h=c?A(u,c):C(u,n[l]);let t=u.length;if(i){if(t!==i.length)throw Error("shape mismatch");for(let e=0;e<t;e++)i[e]+=h[e]*o[l]}else{i=new Array(t);for(let e=0;e<t;e++)i[e]=h[e]*o[l]}}}if(i){if(s){let t=i.length;for(let e=0;e<t;e++)i[e]+=s}return i}return[s]}),s("rcp",function(t,e,r){this.toCube();const n=this.vecInd(t,e,r),o=n.length,i=new Array(o);for(let t=0;t<o;t++)i[t]=this[n[t]];return i}),s("$rcp",function(t,e,r,n){this.toCube();const o=this.vecInd(t,e,r),i=o.length;var[n,s]=f(n);if(s)for(let t=0;t<i;t++)this[o[t]]=n;else{if(n.length!==i)throw Error("shape mismatch");for(let t=0;t<i;t++)this[o[t]]=n[t]}return this}),s("posn",function(t,e){this.toCube(),t=n.dim(t);const r=this.length,[o,i]=this._s;let s;s=0===t?t=>t%o:1===t?t=>Math.floor(t/o)%i:t=>Math.floor(t/(o*i));const l=this.key(t),h=l?t=>l[s(t)]:s;if(Array.isArray(e)){const t=e.length,n=new Array(t);for(let o=0;o<t;o++)n[o]=h(m(e[o],r));return n}return[h(m(e,r))]});{const t=(t,e,r)=>{const n=t._s[e];return 1!==(r=a(r)).length||void 0!==r[0]&&null!==r[0]?t._k&&t._k[e]?[A(r,t._k[e]),!1]:[C(r,n),!1]:[0===n?[]:k(0,n-1),!0]};s("subcube",function(e,r,o,i){if(this.toCube(),"full"!==(i=u(n.single(i),"full"))&&"core"!==i&&"array"!==i)throw Error("'full', 'core', or 'array' expected");const[s,h]=this._s,f=[t(this,0,e),t(this,1,r),t(this,2,o)],c=f[0][0],p=f[1][0],m=f[2][0],y=c.length,_=p.length,w=m.length,E=new Array(y*_*w);let v=0;for(let t=0;t<w;t++){let e=s*h*m[t];for(let t=0;t<_;t++){let r=s*p[t];for(let t=0;t<y;t++)E[v++]=this[c[t]+r+e]}}if("array"===i)return E;if(E.toCube(),E._s[0]=y,E._s[1]=_,E._s[2]=w,"core"===i)return E;if(this._k){d(E);for(let t=0;t<3;t++)this._k[t]&&(E._k[t]=f[t][1]?g(this._k[t]):l(a(0===t?e:1===t?r:o)))}return b(this,E),E}),s("$subcube",function(e,r,n,o){this.toCube();const[i,s]=this._s,l=t(this,0,e)[0],h=t(this,1,r)[0],u=t(this,2,n)[0],a=l.length,c=h.length,g=u.length;var[o,d]=f(o);if(!d&&o.length!==a*c*g)throw Error("shape mismatch");let p=0;for(let t=0;t<g;t++){let e=i*s*u[t];for(let t=0;t<c;t++){let r=i*h[t];for(let t=0;t<a;t++)this[l[t]+r+e]=d?o:o[p++]}}return this}),s("row",function(t,e){return this.subcube(t,null,null,e)}),s("col",function(t,e){return this.subcube(null,t,null,e)}),s("page",function(t,e){return this.subcube(null,null,t,e)}),s("$row",function(t,e){return this.$subcube(t,null,null,e)}),s("$col",function(t,e){return this.$subcube(null,t,null,e)}),s("$page",function(t,e){return this.$subcube(null,null,t,e)});const e=function(t,e,o,i,s,l){e.toCube();const h=t?"$subcube":"subcube";let f;if(i=n.single(i),s=n.single(s),e._k&&e._k[o])f=r.rangeKey(i,s,e._k[o]);else{const t=e._s[o];i=null===i||void 0===i?0:m(i,t),s=null===s||void 0===s?t-1:m(s,t),f=0===t?[]:k(i,s)}switch(o){case 0:return e[h](f,null,null,l);case 1:return e[h](null,f,null,l);case 2:return e[h](null,null,f,l)}};["rowSlice","colSlice","pageSlice","$rowSlice","$colSlice","$pageSlice"].forEach((t,r)=>{s(t,function(t,n,o){return e(r>2,this,r%3,t,n,o)})}),s("head",function(t,e,o,i){this.toCube();const s=new Array(3);for(let i=0;i<3;i++){let l=n.single(0===i?t:1===i?e:o);const h=this._s[i];null===l||void 0===l?l=h:(n.nonNegInt(l),l=Math.min(l,h)),0===l?s[i]=[]:this._k&&this._k[i]?s[i]=r.firstKey(l,this._k[i]):s[i]=k(0,l-1)}return this.subcube(...s,i)})}{const t=(t,e,r,n,o,i)=>{const[s,l,h]=n._s,f=s*l;let u,a=0;if(0===e){u=new Array(l*h);for(let e=0;e<h;e++)for(let r=0;r<l;r++)u[a++]=t[o+s*r+f*e]}else if(1===e){u=new Array(s*h);for(let e=0;e<h;e++)for(let r=0;r<s;r++)u[a++]=t[r+s*o+f*e]}else{u=new Array(s*l);for(let e=0;e<l;e++)for(let r=0;r<s;r++)u[a++]=t[r+s*e+f*o]}if("array"===r)return u;if(u.toCube(),u._s[0]=s,u._s[1]=l,u._s[2]=h,u._s[e]=1,"core"===r)return u;if(y(n,u,e),void 0!==i){d(u);const t=new Map;t.set(i,0),u._k[e]=t}return b(n,u),u},e=(e,r,o)=>{e.toCube(),o=u(n.single(o),"none");const i=e._k&&e._k[r],s=e._s[r];if("none"===o)return i?function*(){for(let t of e._k[r].keys())yield t}():function*(){for(let t=0;t<s;t++)yield t}();{const n=_(e,r);if("full"!==o&&"core"!==o&&"array"!==o)throw Error("'none', 'full', 'core', or 'array' expected");return i?function*(){for(let[i,s]of e._k[r].entries())yield[i,t(e,r,o,n,s,i)]}():function*(){for(let i=0;i<s;i++)yield[i,t(e,r,o,n,i)]}()}};["rows","cols","pages"].forEach((t,r)=>{s(t,function(t){return e(this,r,t)})})}s("vble",function(t){this.toCube(),t=u(n.single(t),0);const{_s:e,_k:o,_l:i}=this,[s,l,h]=e,[f,a,c]=[0,1,2].map(t=>o&&o[t]?[...o[t].keys()]:r.simpleRange(e[t])),[g,d,p]=[0,1,2].map(t=>i&&i[t]||r.shortDimName[t]);let m;if(-1===t){m=new Array(this.length);let t=0;for(let e=0;e<h;e++){let r=s*l*e,n=c[e];for(let e=0;e<l;e++){let o=s*e,i=a[e];for(let e=0;e<s;e++)m[t++]={[g]:f[e],[d]:i,[p]:n,entry:this[e+o+r]}}}}else if(0===t){m=new Array(l*h);let t=0,e=0;for(let r=0;r<h;r++)for(let n=0;n<l;n++){let o={};o[d]=a[n],o[p]=c[r];for(let t=0;t<s;t++)o[f[t]]=this[e++];m[t++]=o}}else if(1===t){m=new Array(s*h);let t=0;for(let e=0;e<h;e++)for(let r=0;r<s;r++){let n=r+e*s*l,o={};o[g]=f[r],o[p]=c[e];for(let t=0;t<l;t++)o[a[t]]=this[n+t*s];m[t++]=o}}else{if(2!==t)throw Error("invalid dimension");{const t=s*l;m=new Array(t);let e=0,r=-1;for(let n=0;n<l;n++)for(let o=0;o<s;o++){r++;let i={};i[g]=f[o],i[d]=a[n];for(let e=0;e<h;e++)i[c[e]]=this[r+e*t];m[e++]=i}}}return m});{const t=["isInteger","isFinite","isNaN"],e=(t,e)=>{e.forEach(e=>{s(e,function(){this.toCube();const r=this.copy("shell"),n=this.length,o=t[e];for(let t=0;t<n;t++)r[t]=o(this[t]);return r})})};e(Math,["sqrt","cbrt","abs","round","floor","ceil","trunc","sign","exp","expm1","log","log10","log2","log1p","sin","cos","tan","asin","acos","atan","sinh","cosh","tanh","asinh","acosh","atanh"]),e(Number,t);const r=[["neg",t=>-t],["number",t=>+t],["string",t=>""+t],["boolean",t=>!!t],["date",t=>new Date(t)],["not",t=>!t],["typeof",t=>typeof t],["trim",t=>t.trim()],["toLowerCase",t=>t.toLowerCase()],["toUpperCase",t=>t.toUpperCase()]];for(let[t,e]of r)s(t,function(){this.toCube();const t=this.copy("shell"),r=this.length;for(let n=0;n<r;n++)t[n]=e(this[n]);return t})}{const t=[["add",(t,e)=>t+e],["sub",(t,e)=>t-e],["mul",(t,e)=>t*e],["div",(t,e)=>t/e],["rem",(t,e)=>t%e],["pow",Math.pow],["atan2",Math.atan2],["hypot",Math.hypot],["eq",(t,e)=>t===e],["neq",(t,e)=>t!==e],["lt",(t,e)=>t<e],["lte",(t,e)=>t<=e],["gt",(t,e)=>t>e],["gte",(t,e)=>t>=e],["lof",(t,e)=>Math.min],["gof",(t,e)=>Math.max],["toExponential",(t,e)=>t.toExponential(e)],["toFixed",(t,e)=>t.toFixed(e)],["toPrecision",(t,e)=>t.toPrecision(e)],["charAt",(t,e)=>t.charAt(e)],["repeat",(t,e)=>t.repeat(e)],["search",(t,e)=>t.search(e)],["test",(t,e)=>t.test(e)],["and",(t,e)=>t&&e],["or",(t,e)=>t||e]];for(let[e,r]of t)s(e,function(t){this.toCube();const n=arguments.length;if(n>1){let r=this[e](t);for(let t=1;t<n;t++)r=r[e](arguments[t]);return r}var[t,o]=f(t);const i=this.length;let s;if(o){s=this.copy("shell");for(let e=0;e<i;e++)s[e]=r(this[e],t)}else{const e=t.length;if(1===i){s=t.copy("shell");const n=this[0];for(let o=0;o<e;o++)s[o]=r(n,t[o])}else{if(i!==e)throw Error("shape mismatch");s=this.copy("shell");for(let e=0;e<i;e++)s[e]=r(this[e],t[e])}}return s})}s("cond",function(t,e){this.toCube();const r=this.length;var[t,n]=f(t);if(!n&&t.length!==r)throw Error("shape mismatch");var[e,o]=f(e);if(!o&&e.length!==r)throw Error("shape mismatch");const i=this.copy("shell");if(n)if(o)for(let n=0;n<r;n++)i[n]=this[n]?t:e;else for(let n=0;n<r;n++)i[n]=this[n]?t:e[n];else if(o)for(let n=0;n<r;n++)i[n]=this[n]?t[n]:e;else for(let n=0;n<r;n++)i[n]=this[n]?t[n]:e[n];return i}),s("method",function(t,...e){this.toCube();const r=this.copy("shell"),n=this.length;var[t,o]=f(t);if(!o&&t.length!==n)throw Error("shape mismatch");const i=o?()=>t:e=>t[e],s=e.length;if(0===s){for(let t=0;t<n;t++)r[t]=this[t][i(t)]();return r}const l=new Array(s);for(let t=0;t<s;t++){let[r,o]=f(e[t]);if(o)l[t]=(()=>r);else{if(r.length!==n)throw Error("shape mismatch");l[t]=(t=>r[t])}}const h=t=>{const e=new Array(s);for(let r=0;r<s;r++)e[r]=l[r](t);return e};for(let t=0;t<n;t++)r[t]=this[t][i(t)](...h(t));return r}),s("prop",function(t){this.toCube(),t=n.single(t);const e=this.length,r=this.copy("shell");for(let n=0;n<e;n++)r[n]=this[n][t];return r}),s("$prop",function(t,e){this.toCube(),t=n.single(t);var[e,r]=f(e);const o=this.length;if(r)if("function"==typeof e)for(let r=0;r<o;r++)this[r][t]=e(this[r],r,this);else for(let r=0;r<o;r++)this[r][t]=e;else{if(e.length!==o)throw Error("shape mismatch");for(let r=0;r<o;r++)this[r][t]=e[r]}return this}),s("cmap",function(t,e){this.toCube();const r=this.map(n.single(t),n.single(e));return r.toCube(),r._s[0]=this._s[0],r._s[1]=this._s[1],r._s[2]=this._s[2],y(this,r),b(this,r),r});{const t=(t,e,r,o,i)=>{t.toCube(),e=u(n.single(e),0),r=n.func(n.single(r)),o=n.single(o);const s=t.length;let l,h,f;if(void 0===o){if(!s)throw Error("must supply init if array/cube empty");l=1}else l=0;if(-1===e)if(h=l?t[0]:o,i){f=[s].cube(),l&&(f[0]=h);for(let e=l;e<s;e++)f[e]=h=r(h,t[e],e,t)}else{for(let e=l;e<s;e++)h=r(h,t[e],e,t);(f=[h]).toCube()}else{const[n,s,u]=t._s,a=n*s;if(i)f=t.copy("shell");else{if(0===e)f=[1,s,u].cube();else if(1===e)f=[n,1,u].cube();else{if(2!==e)throw Error("invalid dimension");f=[n,s,1].cube()}y(t,f,e),b(t,f,e)}if(0===e){let e=0;for(let c=0;c<u;c++){let u=a*c;for(let a=0;a<s;a++){let s=n*a;if(h=l?t[s+u]:o,i){l&&(f[s+u]=h);for(let e=l;e<n;e++){let n=e+s+u;f[n]=h=r(h,t[n],e,t)}}else{for(let e=l;e<n;e++)h=r(h,t[e+s+u],e,t);f[e++]=h}}}}else if(1===e){let e=0;for(let c=0;c<u;c++){let u=a*c;for(let a=0;a<n;a++)if(h=l?t[a+u]:o,i){l&&(f[a+u]=h);for(let e=l;e<s;e++){let o=a+e*n+u;f[o]=h=r(h,t[o],e,t)}}else{for(let e=l;e<s;e++)h=r(h,t[a+e*n+u],e,t);f[e++]=h}}}else{if(2!==e)throw Error("invalid dimension");{let e=0;for(let c=0;c<s;c++){let s=n*c;for(let c=0;c<n;c++)if(h=l?t[c+s]:o,i){l&&(f[c+s]=h);for(let e=l;e<u;e++)vInd=c+s+e*a,f[vInd]=h=r(h,t[vInd],e,t)}else{for(let e=l;e<u;e++)h=r(h,t[c+s+e*a],e,t);f[e++]=h}}}}}return f};s("fold",function(e,r,n){return t(this,e,r,n,!1)}),s("cumu",function(e,r,n){return t(this,e,r,n,!0)});const e=[["sum",(t,e)=>t+ +e,0],["prod",(t,e)=>t*e,1],["all",(t,e)=>t&&!!e,!0],["any",(t,e)=>t||!!e,!1],["count",(t,e)=>t+!!e,0],["min",(t,e)=>Math.min(t,e),1/0],["max",(t,e)=>Math.max(t,e),-1/0]];e.forEach(t=>{s(t[0],function(e){return this.fold(e,t[1],t[2])})}),e.forEach(t=>{s("cumu"+t[0][0].toUpperCase()+t[0].slice(1),function(e){return this.cumu(e,t[1],t[2])})}),s("range",function(t){const e=this.min(t),r=this.max(t),n=r.length;for(let t=0;t<n;t++)r[t]-=e[t];return r}),s("sameType",function(t){return this.fold(t,(t,e)=>((e=typeof e)===t||null===t)&&e,null)});const r=t=>t?(t,e,r)=>t[0]<e?[e,r]:t:(t,e,r)=>t[0]>e?[e,r]:t;["minPosn","maxPosn","cumuMinPosn","cumuMaxPosn"].forEach((t,e)=>{s(t,function(t){const o=e%2;let i=this[e>1?"cumu":"fold"](t,r(o),[[o?-1/0:1/0,null]]);const s=i.length;if(-1!==(t=u(n.single(t),0))&&this._k&&this._k[t]){const e=this.key(t);for(let t=0;t<s;t++){let r=i[t][1];i[t]=null===r?null:e[r]}}else for(let t=0;t<s;t++)i[t]=i[t][1];return i})}),["mean","geoMean"].forEach(t=>{s(t,function(e){const r="geoMean"===t,o=this[r?"prod":"sum"](e);if(-1===(e=u(n.single(e),0)))o[0]=r?Math.pow(o[0],1/this.length):o[0]/this.length;else{const t=o.length;let n=1/this._s[e];if(r)for(let e=0;e<t;e++)o[e]=Math.pow(o[e],n);else for(let e=0;e<t;e++)o[e]*=n}return o})}),s("sew",function(t,e){this.toCube(),e=""+u(n.single(e),",");const r=this.fold(t,(t,r)=>`${t}${e}${null===r||void 0===r?"":r}`,"");if(e){const t=e.length,n=r.length;for(let e=0;e<n;e++)r[e]=r[e].slice(t)}return r}),s("var",function(t,e){this.toCube(),t=u(n.single(t),0),e=n.nonNegInt(u(n.single(e),0));const r=this.fold(t,(t,e)=>{const r=t[0]+1,n=e-t[1],o=t[1]+n/r;return[r,o,t[2]+n*(e-o)]},[[0,0,0]]),o=r.length,i=-1===t?this.length:this._s[t];if(i<2)for(let t=0;t<o;t++)r[t]=NaN;else{let t=i-e;for(let e=0;e<o;e++)r[e]=r[e][2]/t}return r}),s("sd",function(t,e){const r=this.var(t,e),n=r.length;for(let t=0;t<n;t++)r[t]=Math.sqrt(r[t]);return r}),s("wrap",function(t,e){if(this.toCube(),t=u(n.single(t),0),"full"!==(e=u(n.single(e),"full"))&&"core"!==e&&"array"!==e)throw Error("'full', 'core', or 'array' expected");let r;if(-1===t)r=c(this),"array"!==e&&r.toCube(),(r=[r]).toCube();else{const[n,o,i]=this._s,s=this._k,l=t=>s&&s[t]?e=>s[t].get(e):t=>t;if(0===t){r=[1,o,i].cube();const t=l(1),n=l(2);for(let i of this.pages()){let s=n(i)*o;for(let n of this.cols())r[t(n)+s]=this.subcube(null,n,i,e)}}else if(1===t){r=[n,1,i].cube();const t=l(0),o=l(2);for(let i of this.pages()){let s=o(i)*n;for(let n of this.rows())r[t(n)+s]=this.subcube(n,null,i,e)}}else{if(2!==t)throw Error("invalid dimension");{r=[n,o,1].cube();const t=l(0),i=l(1);for(let o of this.cols()){let s=i(o)*n;for(let n of this.rows())r[t(n)+s]=this.subcube(n,o,null,e)}}}y(this,r,t),b(this,r,t)}return r})}s("quantile",function(t,e){this.toCube(),t=u(n.single(t),0);var[e,i]=f(e);let s;if(i&&(void 0===e?(e=[0,.25,.5,.75,1],s=!0):e=[e]),!s&&((e=e.number().toArray()).isNaN().any()[0]||e.lt(0).any()[0]||e.gt(1).any()[0]))throw Error("probabilities must be between 0 and 1 (inclusive)");const l=e.length,h=t=>{const n=t.length;if(0===n)return o(new Array(l),NaN);for(let e=0;e<n;e++){let r=+t[e];if(!Number.isFinite(r))return o(new Array(l),NaN);t[e]=r}t.sort(r.comparison("asc"));const i=e.mul(n-1),s=i.floor(),h=i.sub(s);return t.vec(s).mul([1].sub(h)).add(t.vec(i.ceil()).mul(h))};let a;if(-1===t)a=h(c(this)).$key(0,e);else{if(![0,1,2].includes(t))throw Error("invalid dimension");const r=c(this._s);if(r[t]=l,a=r.cube(),y(this,a,t),b(this,a,t),a.$key(t,e),0===t)for(let t of this.pages())for(let e of this.cols())a.$subcube(null,e,t,h(this.subcube(null,e,t,"array")));else if(1===t)for(let t of this.pages())for(let e of this.rows())a.$subcube(e,null,t,h(this.subcube(e,null,t,"array")));else for(let t of this.cols())for(let e of this.rows())a.$subcube(e,t,null,h(this.subcube(e,t,null,"array")))}return a});{const t=(t,e,n)=>{const o=_(t),i=o._k&&o._k[n],s=e.length;let l=!0;for(let t=0;t<s;t++){let s=e[t];if(Array.isArray(s)){const t=s.length;if(s._data_cube){for(let t=0;t<3;t++)if(t!==n&&o._s[t]!==s._s[t])throw Error("shape mismatch");if(i){if(!s._k||!s._k[n])throw Error(r.dimName[n]+" keys expected");let t=s._k[n],e=i.size;for(let r of t.keys())i.set(r,e++)}o._s[n]+=s._s[n]}else{if(0===n){if(1!==o._s[1]||1!==o._s[2])throw Error("shape mismatch");o._s[0]+=t}else if(1===n){if(o._s[0]!==t||1!==o._s[2])throw Error("shape mismatch");o._s[1]++}else{if(o._s[0]!==t||1!==o._s[1])throw Error("shape mismatch");o._s[2]++}if(i)throw Error(r.dimName[n]+" keys expected")}l=!1}else{for(let t=0;t<3;t++)if(t!==n&&1!==o._s[t])throw Error("shape mismatch");if(i)throw Error(r.dimName[n]+" keys expected");o._s[n]++}}if(i&&i.size!==o._s[n])throw Error("duplicate key");return o.length=o._s[0]*o._s[1]*o._s[2],o._data_cube=!0,[o,l]};["vert","horiz","depth"].forEach((e,r)=>{s(e,function(...e){this.toCube();const[n,o]=t(this,e,r),i=e.length,s=this.length,l=n._s[0],h=n._s[1],f=n._s[2];if(o){let t;for(t=0;t<s;t++)n[t]=this[t];for(let r=0;r<i;r++)n[t++]=e[r]}else if(0===r&&1===h&&1===f||1===r&&1===f||2===r){let t;for(t=0;t<s;t++)n[t]=this[t];for(let r=0;r<i;r++){let o=e[r];if(Array.isArray(o))for(let e=0;e<o.length;e++)n[t++]=o[e];else n[t++]=o}}else{let t=0;for(let o=-1;o<i;o++){let i=-1===o?this:e[o],s=0;if(0===r){let e=i._s[0];for(let r=0;r<f;r++){let o=r*l*h;for(let r=0;r<h;r++){let h=r*l;for(let r=0;r<e;r++)n[r+t+h+o]=i[s++]}}t+=e}else{let e=i._s[1];for(let r=0;r<f;r++){let o=r*l*h;for(let r=0;r<e;r++){let e=(r+t)*l;for(let t=0;t<l;t++)n[t+e+o]=i[s++]}}t+=e}}}return n})})}s("tile",function(t,e,r){if(this.toCube(),t=n.dim(t),e=n.nonNegInt(+u(n.single(e),2)),"full"!==(r=u(n.single(r),"full"))&&"core"!==r)throw Error("'full' or 'core' expected");const o=c(this._s);o[t]*=e;const i=o.cube();if(2===t){const t=this.length;let r=0;for(let n=0;n<e;n++)for(let e=0;e<t;e++)i[r++]=this[e]}else{const[r,n,o]=this._s,[s,l]=i._s;for(let h=0;h<e;h++){let e=0===t?h*r:h*r*n,f=0;for(let t=0;t<o;t++){let o=t*s*l;for(let t=0;t<n;t++){let n=t*s;for(let t=0;t<r;t++)i[t+e+n+o]=this[f++]}}}}return"full"===r&&(y(this,i,t),b(this,i,t)),i}),s("tileTo",function(t,e){if(this.toCube(),"full"!==(e=u(n.single(e),"full"))&&"core"!==e)throw Error("'full' or 'core' expected");if(Array.isArray(t)){if(t._data_cube){let r;for(let o=0;o<3;o++){let i=this._s[o];if(i!==t._s[o]){if(0===i)throw Error("shape mismatch");r=(r||this).tile(o,n.nonNegInt(t._s[o]/i),e)}}return r||this.copy(e)}if(1!==this._s[1]||1!==this._s[2])throw Error("shape mismatch");if(this.length===t.length)return this.copy(e);if(0===this.length)throw Error("shape mismatch");return this.tile(0,n.nonNegInt(t.length/this.length),e)}if(1!==this.length)throw Error("shape mismatch");return this.copy(e)}),s("which",function(t){this.toCube(),t=n.single(t);const e=this.length,r=new Array(e);let o=0;if(void 0!==t){n.func(t);for(let n=0;n<e;n++)t(this[n],n,this)&&(r[o++]=n)}else for(let t=0;t<e;t++)this[t]&&(r[o++]=t);return r.length=o,r}),s("unique",function(){return this.toCube(),[...new Set(this)]}),s("isUnique",function(){return this.toCube(),this.length===this.unique().length}),s("union",function(...t){return this.toCube(),[...new Set(this.concat(...t))]}),s("diff",function(...t){this.toCube();const e=new Set(1===t.length?a(t[0]):[].concat(...t));return this.unique().filter(t=>!e.has(t))}),s("inter",function(...t){this.toCube();const e=t.length;let r=this.unique();for(let n=0;n<e&&0!==r.length;n++){let e=new Set(a(t[n]));r=r.filter(t=>e.has(t))}return r}),s("isIn",function(...t){this.toCube();const e=new Set(1===t.length?a(t[0]):[].concat(...t)),r=this.copy("shell"),n=this.length;for(let t=0;t<n;t++)r[t]=e.has(this[t]);return r}),s("freq",function(t){this.toCube(),t=u(n.single(t),"matrix");const e=this.length;let r;if("vector"===t){const t=new Map,n=new Map;let o=0;for(let r=0;r<e;r++){let e=this[r],i=t.get(e);i?t.set(e,i+1):(t.set(e,1),n.set(void 0===e?"_undefined_":null===e?"_null_":e,o++))}r=[...t.values()].toCube(),d(r),r._k[0]=n}else{if("matrix"!==t)throw Error("'vector' or 'matrix' expected");{r=new Array(e);const t=new Map;let n=0;for(let o=0;o<e;o++){let e=this[o],i=t.get(e);i?t.set(e,i+1):(t.set(e,1),r[n++]=e)}r.length=2*n,r.$shape([n,2]).$key(1,["value","count"]);for(let e of t.values())r[n++]=e}}return r});{const t=(t,e,r,n)=>{const o=c(t._s);o[e]=r.length;const i=o.cube(),s=t._s[0],l=t._s[1],h=i._s[0],f=i._s[1],u=i._s[2];let a=0;if(0===e)for(let e=0;e<u;e++){let n=s*l*e;for(let e=0;e<f;e++){let o=s*e;for(let e=0;e<h;e++)i[a++]=t[r[e]+o+n]}}else if(1===e)for(let e=0;e<u;e++){let n=s*l*e;for(let e=0;e<f;e++){let o=s*r[e];for(let e=0;e<h;e++)i[a++]=t[e+o+n]}}else for(let e=0;e<u;e++){let n=s*l*r[e];for(let e=0;e<f;e++){let r=s*e;for(let e=0;e<h;e++)i[a++]=t[e+r+n]}}return y(t,i,e),b(t,i,e),n&&(t._k&&t._k[e]&&i.$key(e,t.key(e).vec(r)),t._l&&t._l[e]&&i.$label(e,t._l[e])),i};s("flip",function(e){this.toCube(),e=n.dim(e);const r=this._s[e],o=new Array(r);for(let t=0;t<r;t++)o[t]=r-1-t;return t(this,e,o,!0)}),s("roll",function(e,r){this.toCube(),e=n.dim(e),r=n.int(+u(n.single(r),1));const o=this._s[e];r<0&&(r=o- -r%o);const i=new Array(o);for(let t=0;t<o;t++)i[(t+r)%o]=t;return t(this,e,i,!0)}),s("shuffle",function(e,o){this.toCube(),e=n.dim(e);const i=this._s[e];let s;if((o=void 0===(o=n.single(o))||null===o?i:n.nonNegInt(+o))>0){if(o>i)throw Error(`cannot get ${o} shuffled ${r.dimName[e]}s `+`from dimension of length ${i}`);s=r.shuffle(i),o<i&&(s=s.slice(0,o))}else s=[];return t(this,e,s,!0)}),s("sample",function(e,o,i){this.toCube(),e=n.dim(e),o=n.nonNegInt(+u(n.single(o),1));var[i,s]=f(i);let l;const h=this._s[e];if(s)if(void 0===i||null===i)if(o>0){if(0===h)throw Error(`cannot sample ${o} ${r.dimName[e]}s `+"from empty dimension");l=1===h?[o].cube(0):[o].rand(h-1)}else l=[];else{if(1!==h)throw Error("shape mismatch");if(0===(i=n.nonNegFin(+i)))throw Error("at least one probability must be non-zero");l=[o].cube(0)}else{if(i.length!==h)throw Error("shape mismatch");if(h){for(let t=0;t<h;t++)n.nonNegFin(+i[t]);const t=i.number().cumuSum(-1),e=t[h-1];if(0===e)throw Error("at least one probability must be non-zero");l=new Array(o);for(let r=0;r<o;r++){let n=Math.random()*e;for(let e=0;e<h;e++)if(n<t[e]){l[r]=e;break}}}else{if(o)throw Error(`cannot sample ${o} ${r.dimName[e]}s from empty dimension`);l=[]}}return t(this,e,l,!1)}),s("where",function(e,r){this.toCube(),e=n.dim(e);var[r,o]=f(r);o&&("function"==typeof r&&(r=r(this),this.toCube()),r=a(r));const i=this._s[e];if(r.length!==i)throw Error("shape mismatch");const s=new Array(i);let l=0;for(let t=0;t<i;t++)r[t]&&(s[l++]=t);return s.length=l,t(this,e,s,!0)}),s("order",function(e,r,o){this.toCube(),e=n.dim(e);var[r,i]=f(r);if(i&&("function"==typeof r&&(r=r(this),this.toCube()),r=a(r)),r.length!==this._s[e])throw Error("shape mismatch");return o=n.single(o),t(this,e,E(r,o),!0)}),s("orderKey",function(e,r){if(this.toCube(),e=n.dim(e),r=n.single(r),!this._k||!this._k[e])throw Error("dimension does not have keys");const o=this.key(e),i=E(o,r),s=t(this,e,i,!1);return s.$key(e,o.vec(i)),this._l&&this._l[e]&&s.$label(e,this._l[e]),s}),s("group",function(e,r,i){this.toCube(),e=n.dim(e);var[r,s]=f(r);s&&("function"==typeof r&&(r=r(this),this.toCube()),r=a(r));const l=this._s[e],h=r.length;let c=h/l;if(![1,2,3].includes(c)){if(0!==l||0!==h)throw Error("shape mismatch");c=1}if("subcube"!==(i=u(n.single(i),"subcube"))&&"count"!==i&&"function"!=typeof i)throw Error("'subcube', 'count' or function expected");if(0===l)return[].$key(0,[]);const g=new Array(c);let p=0;for(let t=0;t<c;t++){let e=new Map;for(let t=0;t<l;t++){let n=r[p++],o=e.get(n);if(o)o[o.length]=t;else{if("_undefined_"===n||"_null_"===n)throw Error("entry has value '_undefined_' or '_null_'");e.set(n,[t])}}g[t]=e}let m=g.map(t=>t.size),y=o(new Array(l),0);for(let t=0;t<c;t++){let e=0===t?1:1===t?m[0]:m[0]*m[1],r=g[t],n=0;for(let t of r.values()){const r=t.length;for(let o=0;o<r;o++)y[t[o]]+=n*e;n++}}const b=m.cube();for(let t=0;t<l;t++){let e=y[t],r=b[e];r?r[r.length]=t:b[e]=[t]}if(d(b),g.map((t,e)=>{let r=new Map,n=0;for(let e of t.keys())void 0===e?e="_undefined_":null===e&&(e="_null_"),r.set(e,n++);b._k[e]=r}),"function"==typeof i){let r=0,n=(...n)=>{b[r]=i(t(this,e,b[r]||[],!0),...n),r++};if(1===c)for(let t of b.rows())n(t);else if(2===c)for(let t of b.cols())for(let e of b.rows())n(e,t);else for(let t of b.pages())for(let e of b.cols())for(let r of b.rows())n(r,e,t)}else{const r=b.length;for(let n=0;n<r;n++){let r=b[n]||[];b[n]="count"===i?r.length:t(this,e,r,!0)}}return b})}s("arrange",function(t,e){if(this.toCube(),t=n.single(t),"value"===(e=u(n.single(e),"value")))return w(c(this),t);if("index"===e)return E(this,t);if("rank"===e)return v(this,t);throw Error("'value', 'index' or 'rank' expected")}),s("bin",function(t,e,o){this.toCube();const i=(t=c(a(t))).length;if(i<2)throw Error("at least 2 bin limits expected");e=n.single(e);let s=r.comparison(e);var[o,l]=f(o);if(l){if(void 0!==o)throw Error("invalid bin names");t.sort(s),o=t}else{if(o.length!==i)throw Error("number of bin names not equal to number of bins");const r=E(t,e);t=r.map(e=>t[e]),o=r.map(t=>o[t])}if(!o.isUnique())throw Error("bin names not unique");s||(s=((t,e)=>t<=e?-1:1));const h=this.length,u=this.copy("shell");t:for(let e=0;e<h;e++){let r=this[e];for(let n=0;n<i;n++)if(s(r,t[n])<=0){u[e]=o[n];continue t}throw Error("entry not assigned to any bin")}return u}),s("toMatrix",function(){this.toCube();const t=this.length;if(0===t)throw Error("non-empty array/cube expected");const e=Object.keys(this[0]),r=e.length,n=[t,r].cube();n.$key(1,e);for(let o=0;o<t;o++){let i=this[o];for(let s=0;s<r;s++)n[o+t*s]=i[e[s]]}return n});{const e=t=>a(t).toCube();["cube","rand","normal","seq","lin","grid","copy","toArray"].forEach(t=>{e[t]=((e,...r)=>a(e)[t](...r))}),t.exports=e}}})});
