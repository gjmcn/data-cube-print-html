!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.dc=e()}(this,function(){"use strict";function t(t,e){return t(e={exports:{}},e.exports),e.exports}var e=t(function(t){{const e={dimName:["row","column","page"],shortDimName:["row","col","page"],lettersArray:["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"],copyArray:t=>{const e=t.length,r=new Array(e);for(let n=0;n<e;n++)r[n]=t[n];return r},equalArray:(t,e)=>{var r=t.length;if(r!==e.length)return!1;for(var n=0;n<r;n++)if(t[n]!==e[n])return!1;return!0},equalArrayOfArray:(t,r)=>{if(!Array.isArray(t)||!Array.isArray(r))return!1;const n=t.length;if(n!==r.length)return!1;for(let s=0;s<n;s++){if(!Array.isArray(t[s])||!Array.isArray(r[s]))return!1;if(!e.equalArray(t[s],r[s]))return!1}return!0},copyMap:t=>{const e=new Map;for(let[r,n]of t.entries())e.set(r,n);return e},equalMap:(t,e)=>{if(t.size!==e.size)return!1;const r=e.entries();for(let[e,n]of t.entries()){let[t,s]=r.next().value;if(e!==t||n!==s)return!1}return!0},toMap:(...t)=>{const e=t.length;if(e%2!=0)throw Error("even number of arguments expected");const r=new Map;for(let n=0;n<e;n+=2)r.set(t[n],t[n+1]);if(r.size!==e/2)throw Error("duplicate key");return r},keyMap:t=>{const e=t.length,r=new Map;for(let n=0;n<e;n++){let e=t[n];if(void 0===e||null===e)throw Error(`invalid key: ${e}`);r.set(e,n)}if(r.size!==e)throw Error("duplicate key");return r},simpleRange:t=>{t=r.nonNegInt(t);for(var e=new Array(t),n=0;n<t;n++)e[n]=n;return e},shuffle:t=>{t=r.posInt(t);var e,n=new Array(t);n[0]=0;for(var s=1;s<t;s++)e=Math.floor(Math.random()*(s+1)),n[s]=n[e],n[e]=s;return n},fill:(t,e)=>{const r=t.length;for(let n=0;n<r;n++)t[n]=e;return t},fillEW:(t,e)=>{const r=t.length;if(e.length!==r)throw Error("shape mismatch");for(let n=0;n<r;n++)t[n]=e[n];return t},isSingle:t=>!Array.isArray(t)||1===t.length,toArray:t=>Array.isArray(t)?t:[t],polarize:t=>Array.isArray(t)?1===t.length?[t[0],!0]:[t,!1]:[t,!0],def:(t,e)=>void 0===t?e:t,addArrayMethod:(t,e)=>{if(t in Array.prototype)throw Error(t+" is already a property of Array.protoype");Object.defineProperty(Array.prototype,t,{value:e,configurable:!0,enumerable:!1,writable:!0})},ensure:(t,e)=>{t[e]||Object.defineProperty(t,e,{value:new Array(3),configurable:!0,writable:!0})},ensureKey:t=>{e.ensure(t,"_k")},ensureLabel:t=>{e.ensure(t,"_l")},copyKey:(t,r,n)=>{if(t._k)for(let s=0;s<3;s++)s!==n&&t._k[s]&&(e.ensureKey(r),r._k[s]=e.copyMap(t._k[s]))},copyLabel:(t,r,n)=>{if(t._l)for(let s=0;s<3;s++)s!==n&&t._l[s]&&(e.ensureLabel(r),r._l[s]=t._l[s])},skeleton:(t,r,n)=>{const s=[];return Object.defineProperty(s,"_s",{value:e.copyArray(t._s),writable:!0}),e.copyKey(t,s,r),e.copyLabel(t,s,n),s},nni:(t,e)=>{if(!Number.isInteger(t))throw Error("integer expected");if(t>=e||t<-e)throw Error("index out of bounds");return t<0?t+e:t},rangeKey:(t,e,r)=>{const n=new Array(r.size);let s=null===t||void 0===t?1:0;const i=null!==e&&void 0!==e;let o=0;for(let l of r.keys())if(s){if(n[o++]=l,i&&l===e){s=2;break}}else if(l===t){if(n[o++]=l,i&&t===e){s=2;break}s=1}if(0===s)throw Error("start key does not exist");if(i&&1===s)throw Error("end-key does not exist or is before start-key");return n.length=o,n},firstKey:(t,e)=>{const r=new Array(t);let n=0;for(let s of e.keys()){if(n===t)break;r[n++]=s}return r.length=n,r},rangeInd:(t,e)=>{if(e<t)throw Error("end less than start");const r=new Array(e-t+1);let n=0;for(let s=t;s<=e;s++)r[n++]=s;return r},indInd:(t,r)=>{const n=t.length,s=new Array(n);for(let i=0;i<n;i++)s[i]=e.nni(t[i],r);return s},keyInd:(t,e)=>{const r=t.length,n=new Array(r);for(let s=0;s<r;s++){let r=e.get(t[s]);if(void 0===r)throw Error("key does not exist");n[s]=r}return n},timer:t=>{const e=process.hrtime();t();const r=process.hrtime(e);return Math.round((1e9*r[0]+r[1])/1e6)}};{const t=e.lettersArray,r=new Map;for(let e=0;e<t.length;e++)r.set(t[e],e);e.lettersMap=r}const r={nonNegInt:t=>{if(!Number.isInteger(t)||t<0)throw Error("non-negative integer expected");return t},posInt:t=>{if(!Number.isInteger(t)||t<=0)throw Error("positive integer expected");return t},number:t=>{if("number"!=typeof t)throw Error("number expected");return t},dim:t=>{if(void 0===(t=r.single(t)))return 0;if(0!==t&&1!==t&&2!==t)throw Error("invalid dimension");return t},single:t=>{if(Array.isArray(t)){if(1!==t.length)throw Error("singleton expected");return t[0]}return t},func:t=>{if("function"!=typeof t)throw Error("function expected");return t},argRange:(t,e,r)=>{const n=t.length;if(n<e)throw Error("too few arguments");if(n>r)throw Error("too many arguments");return n},dataMatrix:t=>{if(1!==t._s[2]||0===t._s[1])throw Error("matrix with at least 1 column expected")}};e.assert=r,t.exports=e}});return t(function(t){{const r=e,{assert:n,fill:s,fillEW:i,addArrayMethod:o,keyMap:l,isSingle:h,polarize:a,def:f,toArray:c,copyArray:u,copyMap:_,ensureKey:g,ensureLabel:d,nni:y,copyKey:p,copyLabel:m,skeleton:b}=r;["_data_cube","_s","_k","_l"].forEach(t=>{if(t in Array.prototype)throw Error(t+" is a property of Array.protoype")});{const t={};["copyWithin","fill","pop","push","reverse","shift","sort","splice","unshift"].forEach(e=>{t[e]=Array.prototype[e],delete Array.prototype[e],o(e,function(){if(this._data_cube)throw Error(`native array method ${e} cannot be used with cubes`);return t[e].apply(this,arguments)})})}const w=t=>{Object.defineProperty(t,"length",{writable:!1}),Object.defineProperty(t,"_data_cube",{value:!0}),Object.defineProperty(t,"_s",{value:[t.length,1,1],writable:!0})};o("toCube",function(){return this._data_cube||w(this),this});const k=t=>{Object.defineProperty(t,"length",{writable:!1}),Object.defineProperty(t,"_data_cube",{value:!0})};o("compare",function(t,e){if(this._data_cube||w(this),e=f(n.single(e),!0),this===t)return this;let s;if(s=e?t=>{throw Error(t)}:()=>!1,!Array.isArray(t))return s("cube compared to non-array");const i=this.length;if(i!==t.length)return s("number of entries not equal");for(let e=0;e<i;e++)if(this[e]!==t[e])return s(`entries at vector index ${e} not equal`);if(t._data_cube){if(!r.equalArray(this._s,t._s))return s("shape not equal");const e=this._k,n=t._k;if(e){if(!n)return s("keys-indices");for(let t=0;t<3;t++)if(e[t]){if(!n[t])return s(`keys-indices, ${r.dimName[t]}s`);if(!r.equalMap(e[t],n[t]))return s(`${r.dimName[t]} keys not equal`)}else if(n[t])return s("indices-keys")}else if(n)return s("indices-keys");const i=this._l,o=t._l;if(i){if(!o)return s("labels not equal or not used on same dimensions");if(!r.equalArray(i,o))return s("labels not equal or not used on same dimensions")}else if(o)return s("labels not equal or not used on same dimensions")}else{if(1!==this._s[1]||1!==this._s[2])return s("shape not equal");if(this._k)return s("keys-indices");if(this._l)return s("labels not equal or not used on same dimensions")}return this}),o("cube",function(t){if(this.length>3)throw Error("shape cannot have more than 3 entries");const e=void 0===this[0]?1:n.nonNegInt(this[0]),r=void 0===this[1]?1:n.nonNegInt(this[1]),o=void 0===this[2]?1:n.nonNegInt(this[2]),l=new Array(e*r*o);w(l),l._s[0]=e,l._s[1]=r,l._s[2]=o;var[t,h]=a(t);return void 0!==t&&(h?s:i)(l,t),l}),o("rand",function(t){t=n.single(t);const e=this.cube(),r=e.length;if(void 0!==t){const s=n.posInt(t)+1;for(let t=0;t<r;t++)e[t]=Math.floor(Math.random()*s)}else for(let t=0;t<r;t++)e[t]=Math.random();return e}),o("normal",function(t,e){const r=()=>{let t,e,r;for(;;)if((r=(t=2*Math.random()-1)*t+(e=2*Math.random()-1)*e)>0&&r<1)return t*Math.sqrt(-2*Math.log(r)/r)};if(t=n.number(f(n.single(t),0)),(e=n.number(f(n.single(e),1)))<=0)throw Error("positive number expected (standard deviation)");const s=this.cube(),i=s.length;for(let n=0;n<i;n++)s[n]=r()*e+t;return s}),o("shape",function(){return this._data_cube||w(this),u(this._s)}),o("$shape",function(t){this._data_cube||w(this),n.argRange(arguments,0,1);var[t,e]=a(t);let r=1,s=1,i=1;const o=0===this.length;if(void 0===t)r=this.length;else if(e)if(0===(r=n.nonNegInt(t))){if(!o)throw Error("number of entries cannot change")}else s=o?0:n.nonNegInt(this.length/r);else if(2===t.length)if((r=n.nonNegInt(t[0]))*(s=n.nonNegInt(t[1]))==0){if(!o)throw Error("number of entries cannot change")}else i=o?0:n.nonNegInt(this.length/(r*s));else{if(3!==t.length)throw Error("shape must have 1-3 entries");if((r=n.nonNegInt(t[0]))*(s=n.nonNegInt(t[1]))*(i=n.nonNegInt(t[2]))!==this.length)throw Error("number of entries cannot change")}return this._s[0]=r,this._s[1]=s,this._s[2]=i,this._k&&delete this._k,this._l&&delete this._l,this}),o("n",function(t){return this._data_cube||w(this),t=n.dim(t),this._s[t]}),o("label",function(t){return this._data_cube||w(this),t=n.dim(t),this._l&&this._l[t]||null}),o("$label",function(t,e){if(this._data_cube||w(this),1===n.argRange(arguments,1,2)&&([t,e]=[void 0,t]),t=n.dim(t),null===(e=n.single(e))){const e=this._l;e&&e[t]&&(e[t]=void 0,e[0]||e[1]||e[2]||delete this._l)}else{if(""===(e=""+e))throw Error("label cannot be empty string");d(this),this._l[t]=e}return this}),o("key",function(t){if(this._data_cube||w(this),t=n.dim(t),this._k){const e=this._k[t];if(e)return[...e.keys()]}return null}),o("$key",function(t,e){if(this._data_cube||w(this),1===n.argRange(arguments,1,2)&&([t,e]=[void 0,t]),t=n.dim(t),1===(e=c(e)).length&&null===e[0]){const e=this._k;e&&e[t]&&(e[t]=void 0,e[0]||e[1]||e[2]||delete this._k)}else{const r=l(e);if(this._s[t]!==r.size)throw Error("shape mismatch");g(this),this._k[t]=r}return this}),o("$strip",function(){return this._data_cube||w(this),n.argRange(arguments,0,0),delete this._k,delete this._l,this}),o("copy",function(t){if("full"!==(t=f(n.single(t),"full"))&&"core"!==t&&"shell"!==t&&"array"!==t)throw Error("'full', 'core', 'shell' or 'array' expected");if("array"===t)return u(this);const e="shell"===t?new Array(this.length):u(this);if(w(e),this._data_cube&&(e._s[0]=this._s[0],e._s[1]=this._s[1],e._s[2]=this._s[2],"core"!==t&&(this._l&&(d(e),e._l[0]=this._l[0],e._l[1]=this._l[1],e._l[2]=this._l[2]),this._k))){g(e);for(let t=0;t<3;t++)this._k[t]&&(e._k[t]=_(this._k[t]))}return e}),o("hasKey",function(t,e){this._data_cube||w(this),t=n.dim(t),e=n.single(e);const r=this._k,s=!(!r||!r[t]);return void 0===e?s:s&&r[t].has(e)});{const t=(t,e,r)=>void 0===r||null===r?0:t._k&&t._k[e]?n.number(t._k[e].get(r)):y(r,t._s[e]);o("at",function(e,r,s){if(this._data_cube||w(this),0===this.length)throw Error("cube has no entries");const i=arguments.length;if(i<=1)return this[t(this,0,n.single(e))];if(2===i)return this[t(this,0,n.single(e))+t(this,1,n.single(r))*this._s[0]];{const i=this._s;return this[t(this,0,n.single(e))+t(this,1,n.single(r))*i[0]+t(this,2,n.single(s))*i[0]*i[1]]}}),o("$at",function(e,r,s,i){if(this._data_cube||w(this),0===this.length)throw Error("cube has no entries");const o=n.argRange(arguments,1,4);if(2===o)this[t(this,0,n.single(e))]=n.single(r);else if(3===o)this[t(this,0,n.single(e))+t(this,1,n.single(r))*this._s[0]]=n.single(s);else if(4===o){const o=this._s;this[t(this,0,n.single(e))+t(this,1,n.single(r))*o[0]+t(this,2,n.single(s))*o[0]*o[1]]=n.single(i)}else this[0]=n.single(e);return this})}o("vec",function(t){this._data_cube||w(this);var[t,e]=a(t);const r=this.length;if(e)return void 0===t||null===t?u(this):[this[y(t,r)]];const n=t.length,s=new Array(n);for(let e=0;e<n;e++)s[e]=this[y(t[e],r)];return s}),o("$vec",function(t,e){this._data_cube||w(this);n.argRange(arguments,1,2);1===arguments.length&&([t,e]=[null,t]);const r=this.length;var[t,o]=a(t),[e,l]=a(e);if(o)if(void 0===t||null===t)(l?s:i)(this,e);else{if(!l)throw Error("shape mismatch");this[y(t,r)]=e}else{const n=t.length,s=new Array(n);for(let e=0;e<n;e++)s[e]=y(t[e],r);if(l)for(let t=0;t<n;t++)this[s[t]]=e;else{if(e.length!==n)throw Error("shape mismatch");for(let t=0;t<n;t++)this[s[t]]=e[t]}}return this});{const{rangeInd:t,keyInd:e,indInd:s}=r,i=(r,n,i)=>{const o=r._s[n];return 1!==(i=c(i)).length||void 0!==i[0]&&null!==i[0]?r._k&&r._k[n]?[e(i,r._k[n]),!1]:[s(i,o),!1]:[0===o?[]:t(0,o-1),!0]};o("sc",function(t,e,r,s){if(this._data_cube||w(this),"full"!==(s=f(n.single(s),"full"))&&"core"!==s&&"array"!==s)throw Error("'full', 'core', or 'array' expected");const[o,h]=this._s,a=[i(this,0,t),i(this,1,e),i(this,2,r)],u=a[0][0],d=a[1][0],y=a[2][0],p=u.length,b=d.length,k=y.length,E=new Array(p*b*k);let A=0;for(let t=0;t<k;t++){let e=o*h*y[t];for(let t=0;t<b;t++){let r=o*d[t];for(let t=0;t<p;t++)E[A++]=this[u[t]+r+e]}}if("array"===s)return E;if(w(E),E._s[0]=p,E._s[1]=b,E._s[2]=k,"core"===s)return E;if(this._k){g(E);for(let t=0;t<3;t++)this._k[t]&&(E._k[t]=a[t][1]?_(this._k[t]):l(c(arguments[t])))}return m(this,E),E}),o("$sc",function(t,e,r,s){switch(this._data_cube||w(this),n.argRange(arguments,1,4)){case 1:[t,e,r,s]=[,,,t];break;case 2:[t,e,r,s]=[t,,,e];break;case 3:[t,e,r,s]=[t,e,,r]}const[o,l]=this._s,h=i(this,0,t)[0],f=i(this,1,e)[0],c=i(this,2,r)[0],u=h.length,_=f.length,g=c.length;var[s,d]=a(s);if(!d&&s.length!==u*_*g)throw Error("shape mismatch");let y=0;for(let t=0;t<g;t++){let e=o*l*c[t];for(let t=0;t<_;t++){let r=o*f[t];for(let t=0;t<u;t++)this[h[t]+r+e]=d?s:s[y++]}}return this}),o("row",function(t,e){return this.sc(t,null,null,e)}),o("col",function(t,e){return this.sc(null,t,null,e)}),o("page",function(t,e){return this.sc(null,null,t,e)}),o("$row",function(t,e){return 1===n.argRange(arguments,1,2)?this.$sc(t):this.$sc(t,null,null,e)}),o("$col",function(t,e){return 1===n.argRange(arguments,1,2)?this.$sc(t):this.$sc(null,t,null,e)}),o("$page",function(t,e){return 1===n.argRange(arguments,1,2)?this.$sc(t):this.$sc(null,null,t,e)});const h=function(e,s,i,o,l,h){let a,f;if(s._data_cube||w(s),e){switch(n.argRange(arguments,4,6)){case 4:[o,l,h]=[null,null,o];break;case 5:[o,l,h]=[o,null,l]}a="$sc"}else a="sc";if(o=n.single(o),l=n.single(l),s._k&&s._k[i])f=r.rangeKey(o,l,s._k[i]);else{const e=s._s[i];o=null===o||void 0===o?0:y(o,e),l=null===l||void 0===l?e-1:y(l,e),f=0===e?[]:t(o,l)}switch(i){case 0:return s[a](f,null,null,h);case 1:return s[a](null,f,null,h);case 2:return s[a](null,null,f,h)}};["down","along","back","$down","$along","$back"].forEach((t,e)=>{o(t,function(t,r,n){return h(e>2,this,e%3,...arguments)})}),o("head",function(e,s,i,o){this._data_cube||w(this);const l=new Array(3);for(let e=0;e<3;e++){let s=n.single(arguments[e]);const i=this._s[e];null===s||void 0===s?s=i:(n.nonNegInt(s),s=Math.min(s,i)),0===s?l[e]=[]:this._k&&this._k[e]?l[e]=r.firstKey(s,this._k[e]):l[e]=t(0,s-1)}return this.sc(...l,o)})}{const t=(t,e,r,n,s,i)=>{const[o,l,h]=n._s,a=o*l;let f,c=0;if(0===e){f=new Array(l*h);for(let e=0;e<h;e++)for(let r=0;r<l;r++)f[c++]=t[s+o*r+a*e]}else if(1===e){f=new Array(o*h);for(let e=0;e<h;e++)for(let r=0;r<o;r++)f[c++]=t[r+o*s+a*e]}else{f=new Array(o*l);for(let e=0;e<l;e++)for(let r=0;r<o;r++)f[c++]=t[r+o*e+a*s]}if("array"===r)return f;if(w(f),f._s[0]=o,f._s[1]=l,f._s[2]=h,f._s[e]=1,"core"===r)return f;if(p(n,f,e),void 0!==i){g(f);const t=new Map;t.set(i,0),f._k[e]=t}return m(n,f),f},e=(e,r,s)=>{e._data_cube||w(e),s=f(n.single(s),"none");const i=e._k&&e._k[r],o=e._s[r];if("none"===s)return i?function*(){for(let t of e._k[r].keys())yield t}():function*(){for(let t=0;t<o;t++)yield t}();{const n=b(e,r);if("full"!==s&&"core"!==s&&"array"!==s)throw Error("'none', 'full', 'core', or 'array' expected");return i?function*(){for(let[i,o]of e._k[r].entries())yield[i,t(e,r,s,n,o,i)]}():function*(){for(let i=0;i<o;i++)yield[i,t(e,r,s,n,i)]}()}};["rows","cols","pages"].forEach((t,r)=>{o(t,function(t){return e(this,r,t)})})}o("vble",function(t){this._data_cube||w(this),t=f(n.single(t),0);const e=["r_","c_","p_"],{_s:s,_k:i,_l:o}=this,[l,h,a]=s,[c,u,_]=[0,1,2].map(t=>i&&i[t]?[...i[t].keys()]:r.simpleRange(s[t]).map(r=>e[t]+r)),[g,d,y]=[0,1,2].map(t=>o&&o[t]||r.shortDimName[t]);let p;if(-1===t){p=new Array(this.length);let t=0;for(let e=0;e<a;e++){let r=l*h*e;for(let n=0;n<h;n++){let s=l*n;for(let i=0;i<l;i++)p[t++]={[g]:c[i],[d]:u[n],[y]:_[e],entry:this[i+s+r]}}}}else if(0===t){p=new Array(h*a);let t=0,e=0;for(let r=0;r<a;r++)for(let n=0;n<h;n++){let s={};s[d]=u[n],s[y]=_[r];for(let t=0;t<l;t++)s[c[t]]=this[e++];p[t++]=s}}else if(1===t){p=new Array(l*a);let t=0;for(let e=0;e<a;e++)for(let r=0;r<l;r++){let n=r+e*l*h,s={};s[g]=c[r],s[y]=_[e];for(let t=0;t<h;t++)s[u[t]]=this[n+t*l];p[t++]=s}}else{if(2!==t)throw Error("invalid dimension");{const t=l*h;p=new Array(t);let e=0,r=-1;for(let n=0;n<h;n++)for(let s=0;s<l;s++){r++;let i={};i[g]=c[s],i[d]=u[n];for(let e=0;e<a;e++)i[_[e]]=this[r+e*t];p[e++]=i}}}return p});{const t=["isInteger","isFinite","isNaN"],e=(t,e)=>{e.forEach(e=>{o(e,function(){this._data_cube||w(this);const r=this.copy("shell"),n=this.length,s=t[e];for(let t=0;t<n;t++)r[t]=s(this[t]);return r})})};e(Math,["sqrt","cbrt","abs","round","floor","ceil","trunc","sign","exp","expm1","log","log10","log2","log1p","sin","cos","tan","asin","acos","atan","sinh","cosh","tanh","asinh","acosh","atanh"]),e(Number,t);const r=[["neg",t=>-t],["number",t=>+t],["string",t=>""+t],["boolean",t=>!!t],["date",t=>new Date(t)],["not",t=>!t],["typeof",t=>typeof t],["trim",t=>t.trim()],["toLowerCase",t=>t.toLowerCase()],["toUpperCase",t=>t.toUpperCase()]];for(let[t,e]of r)o(t,function(){this._data_cube||w(this);const t=this.copy("shell"),r=this.length;for(let n=0;n<r;n++)t[n]=e(this[n]);return t})}{const t=[["add",(t,e)=>t+e],["sub",(t,e)=>t-e],["mul",(t,e)=>t*e],["div",(t,e)=>t/e],["rem",(t,e)=>t%e],["pow",Math.pow],["atan2",Math.atan2],["hypot",Math.hypot],["eq",(t,e)=>t===e],["neq",(t,e)=>t!==e],["lt",(t,e)=>t<e],["lte",(t,e)=>t<=e],["gt",(t,e)=>t>e],["gte",(t,e)=>t>=e],["lof",(t,e)=>Math.min],["gof",(t,e)=>Math.max],["toExponential",(t,e)=>t.toExponential(e)],["toFixed",(t,e)=>t.toFixed(e)],["toPrecision",(t,e)=>t.toPrecision(e)],["charAt",(t,e)=>t.charAt(e)],["repeat",(t,e)=>t.repeat(e)],["search",(t,e)=>t.search(e)],["test",(t,e)=>t.test(e)],["and",(t,e)=>t&&e],["or",(t,e)=>t||e]];for(let[e,r]of t)o(e,function(t){this._data_cube||w(this);const n=arguments.length;if(n>1){let r=this[e](t);for(let t=1;t<n;t++)r=r[e](arguments[t]);return r}var[t,s]=a(t);const i=this.length;let o;if(s){o=this.copy("shell");for(let e=0;e<i;e++)o[e]=r(this[e],t)}else{const e=t.length;if(1===i){o=t.copy("shell");const n=this[0];for(let s=0;s<e;s++)o[s]=r(n,t[s])}else{if(i!==e)throw Error("shape mismatch");o=this.copy("shell");for(let e=0;e<i;e++)o[e]=r(this[e],t[e])}}return o})}o("method",function(t,...e){this._data_cube||w(this);const r=this.copy("shell"),n=this.length;var[t,s]=a(t);if(!s&&t.length!==n)throw Error("shape mismatch");const i=s?()=>t:e=>t[e],o=e.length;if(0===o){for(let t=0;t<n;t++)r[t]=this[t][i(t)]();return r}const l=new Array(o);for(let t=0;t<o;t++){let[r,s]=a(e[t]);if(s)l[t]=(()=>r);else{if(r.length!==n)throw Error("shape mismatch");l[t]=(t=>r[t])}}const h=t=>{const e=new Array(o);for(let r=0;r<o;r++)e[r]=l[r](t);return e};for(let t=0;t<n;t++)r[t]=this[t][i(t)](...h(t));return r});{const t=(t,e,r)=>{"prop"!==e||t._data_cube||w(t);const n=t.length;var[r,s]=a(r);if(!s&&r.length!==n)throw Error("shape mismatch");const i="prop"===e?t.copy("shell"):new Array(n),o=s?()=>r:t=>r[t];if("prop"===e)for(let e=0;e<n;e++)i[e]=t[e][o(e)];else if("style"===e)for(let e=0;e<n;e++)i[e]=window.getComputedStyle(t[e])[o(e)];else if("attr"===e)for(let e=0;e<n;e++)i[e]=t[e].getAttribute(o(e));else if("hasAttr"===e)for(let e=0;e<n;e++)i[e]=t[e].hasAttribute(o(e));else{if("hasClass"!==e)throw Error("invalid argument");for(let e=0;e<n;e++)i[e]=t[e].classList.contains(o(e))}return i};["prop","attr","style","hasAttr","hasClass"].forEach(e=>{o(e,function(r){return t(this,e,r)})});const e=(t,e,r)=>{"$prop"!==e||t._data_cube||w(t);const n=t.length,s=r.length;if(s<2||s%2!=0)throw Error("invalid number of arguments");const i=s/2,o=new Array(i),l=new Array(i);for(let e=0;e<i;e++){let[s,i]=a(r[2*e]),[h,f]=a(r[2*e+1]);if(!i&&s.length!==n)throw Error("shape mismatch");if(!f&&h.length!==n)throw Error("shape mismatch");o[e]=i?()=>s:t=>s[t],l[e]=f?"function"==typeof h?e=>h(t[e],e,t):()=>h:e=>"function"==typeof h[e]?h[e](t[e],e,t):h[e]}for(let r=0;r<i;r++){let s=o[r],i=l[r];if("$prop"===e)for(let e=0;e<n;e++)t[e][s(e)]=i(e);else if("$style"===e)for(let e=0;e<n;e++)t[e].style[s(e)]=i(e);else{if("$attr"!==e)throw Error("invalid argument");for(let e=0;e<n;e++)t[e].setAttribute(s(e),i(e))}}return t};["$prop","$attr","$style"].forEach(t=>{o(t,function(...r){return e(this,t,r)})})}o("cmap",function(t,e){this._data_cube||w(this);const r=this.map(n.single(t),n.single(e));return w(r),r._s[0]=this._s[0],r._s[1]=this._s[1],r._s[2]=this._s[2],p(this,r),m(this,r),r});{const t=(t,e,r,s,i)=>{t._data_cube||w(t),e=f(n.single(e),0),r=n.func(n.single(r)),s=n.single(s);const o=t.length;let l,h,a;if(void 0===s){if(!o)throw Error("must supply init if array/cube empty");l=1}else l=0;if(-1===e)if(h=l?t[0]:s,i){a=[o].cube(),l&&(a[0]=h);for(let e=l;e<o;e++)a[e]=h=r(h,t[e],e,t)}else{for(let e=l;e<o;e++)h=r(h,t[e],e,t);w(a=[h])}else{const[n,o,f]=t._s,c=n*o;if(i)a=t.copy("shell");else{if(0===e)a=[1,o,f].cube();else if(1===e)a=[n,1,f].cube();else{if(2!==e)throw Error("invalid dimension");a=[n,o,1].cube()}p(t,a,e),m(t,a,e)}if(0===e){let e=0;for(let u=0;u<f;u++){let f=c*u;for(let c=0;c<o;c++){let o=n*c;if(h=l?t[o+f]:s,i){l&&(a[o+f]=h);for(let e=l;e<n;e++){let n=e+o+f;a[n]=h=r(h,t[n],e,t)}}else{for(let e=l;e<n;e++)h=r(h,t[e+o+f],e,t);a[e++]=h}}}}else if(1===e){let e=0;for(let u=0;u<f;u++){let f=c*u;for(let c=0;c<n;c++)if(h=l?t[c+f]:s,i){l&&(a[c+f]=h);for(let e=l;e<o;e++){let s=c+e*n+f;a[s]=h=r(h,t[s],e,t)}}else{for(let e=l;e<o;e++)h=r(h,t[c+e*n+f],e,t);a[e++]=h}}}else{if(2!==e)throw Error("invalid dimension");{let e=0;for(let u=0;u<o;u++){let o=n*u;for(let u=0;u<n;u++)if(h=l?t[u+o]:s,i){l&&(a[u+o]=h);for(let e=l;e<f;e++)vInd=u+o+e*c,a[vInd]=h=r(h,t[vInd],e,t)}else{for(let e=l;e<f;e++)h=r(h,t[u+o+e*c],e,t);a[e++]=h}}}}}return a};o("fold",function(e,r,n){return t(this,e,r,n,!1)}),o("cumu",function(e,r,n){return t(this,e,r,n,!0)});const e=[["sum",(t,e)=>t+ +e,0],["prod",(t,e)=>t*e,1],["all",(t,e)=>t&&!!e,!0],["any",(t,e)=>t||!!e,!1],["count",(t,e)=>t+!!e,0],["min",(t,e)=>Math.min(t,e),1/0],["max",(t,e)=>Math.max(t,e),-1/0]];e.forEach(t=>{o(t[0],function(e){return this.fold(e,t[1],t[2])})}),e.forEach(t=>{o("cumu"+t[0][0].toUpperCase()+t[0].slice(1),function(e){return this.cumu(e,t[1],t[2])})}),o("range",function(t){const e=this.min(t),r=this.max(t),n=r.length;for(let t=0;t<n;t++)r[t]-=e[t];return r}),o("sameType",function(t){return this.fold(t,(t,e)=>((e=typeof e)===t||null===t)&&e,null)});const r=t=>t?(t,e,r)=>t[0]<e?[e,r]:t:(t,e,r)=>t[0]>e?[e,r]:t;["minPosn","maxPosn","cumuMinPosn","cumuMaxPosn"].forEach((t,e)=>{o(t,function(t){const s=e%2;let i=this[e>1?"cumu":"fold"](t,r(s),[[s?-1/0:1/0,null]]);const o=i.length;if(-1!==(t=f(n.single(t),0))&&this._k&&this._k[t]){const e=this.key(t);for(let t=0;t<o;t++){let r=i[t][1];i[t]=null===r?null:e[r]}}else for(let t=0;t<o;t++)i[t]=i[t][1];return i})}),["mean","geoMean"].forEach(t=>{o(t,function(e){const r="geoMean"===t,s=this[r?"prod":"sum"](e);if(-1===(e=f(n.single(e),0)))s[0]=r?Math.pow(s[0],1/this.length):s[0]/this.length;else{const t=s.length;let n=1/this._s[e];if(r)for(let e=0;e<t;e++)s[e]=Math.pow(s[e],n);else for(let e=0;e<t;e++)s[e]*=n}return s})}),o("sew",function(t,e){this._data_cube||w(this),e=""+f(n.single(e),",");const r=this.fold(t,(t,r)=>`${t}${e}${null===r||void 0===r?"":r}`,"");if(e){const t=e.length,n=r.length;for(let e=0;e<n;e++)r[e]=r[e].slice(t)}return r}),o("var",function(t,e){this._data_cube||w(this),t=f(n.single(t),0),e=n.nonNegInt(f(n.single(e),0));const r=this.fold(t,(t,e)=>{const r=t[0]+1,n=e-t[1],s=t[1]+n/r;return[r,s,t[2]+n*(e-s)]},[[0,0,0]]),s=r.length,i=-1===t?this.length:this._s[t];if(i<2)for(let t=0;t<s;t++)r[t]=NaN;else{let t=i-e;for(let e=0;e<s;e++)r[e]=r[e][2]/t}return r}),o("sd",function(t,e){const r=this.var(t,e),n=r.length;for(let t=0;t<n;t++)r[t]=Math.sqrt(r[t]);return r}),o("wrap",function(t,e){if(this._data_cube||w(this),t=f(n.single(t),0),"full"!==(e=f(n.single(e),"full"))&&"core"!==e&&"array"!==e)throw Error("'full', 'core', or 'array' expected");let r;if(-1===t)r=u(this),"array"!==e&&w(r),w(r=[r]);else{const[n,s,i]=this._s,o=this._k,l=t=>o&&o[t]?e=>o[t].get(e):t=>t;if(0===t){r=[1,s,i].cube();const t=l(1),n=l(2);for(let i of this.pages()){let o=n(i)*s;for(let n of this.cols())r[t(n)+o]=this.sc(null,n,i,e)}}else if(1===t){r=[n,1,i].cube();const t=l(0),s=l(2);for(let i of this.pages()){let o=s(i)*n;for(let n of this.rows())r[t(n)+o]=this.sc(n,null,i,e)}}else{if(2!==t)throw Error("invalid dimension");{r=[n,s,1].cube();const t=l(0),i=l(1);for(let s of this.cols()){let o=i(s)*n;for(let n of this.rows())r[t(n)+o]=this.sc(n,s,null,e)}}}p(this,r,t),m(this,r,t)}return r})}{const t=(t,e,n)=>{const s=b(t),i=s._k&&s._k[n],o=e.length;let l=!0;for(let t=0;t<o;t++){let o=e[t];if(Array.isArray(o)){const t=o.length;if(o._data_cube){for(let t=0;t<3;t++)if(t!==n&&s._s[t]!==o._s[t])throw Error("shape mismatch");if(i){if(!o._k||!o._k[n])throw Error(r.dimName[n]+" keys expected");let t=o._k[n],e=i.size;for(let r of t.keys())i.set(r,e++)}s._s[n]+=o._s[n]}else{if(0===n){if(1!==s._s[1]||1!==s._s[2])throw Error("shape mismatch");s._s[0]+=t}else if(1===n){if(s._s[0]!==t||1!==s._s[2])throw Error("shape mismatch");s._s[1]++}else{if(s._s[0]!==t||1!==s._s[1])throw Error("shape mismatch");s._s[2]++}if(i)throw Error(r.dimName[n]+" keys expected")}l=!1}else{for(let t=0;t<3;t++)if(t!==n&&1!==s._s[t])throw Error("shape mismatch");if(i)throw Error(r.dimName[n]+" keys expected");s._s[n]++}}if(i&&i.size!==s._s[n])throw Error("duplicate key");return s.length=s._s[0]*s._s[1]*s._s[2],k(s),[s,l]};["v","h","d"].forEach((e,r)=>{o(e,function(...e){this._data_cube||w(this);const[n,s]=t(this,e,r),i=e.length,o=this.length,l=n._s[0],h=n._s[1],a=n._s[2];if(s){let t;for(t=0;t<o;t++)n[t]=this[t];for(let r=0;r<i;r++)n[t++]=e[r]}else if(0===r&&1===h&&1===a||1===r&&1===a||2===r){let t;for(t=0;t<o;t++)n[t]=this[t];for(let r=0;r<i;r++){let s=e[r];if(Array.isArray(s))for(let e=0;e<s.length;e++)n[t++]=s[e];else n[t++]=s}}else{let t=0;for(let s=-1;s<i;s++){let i=-1===s?this:e[s];if(0===r){let e=i._s[0];for(let r=0;r<a;r++){let s=r*e*h,o=r*l*h;for(let r=0;r<h;r++){let h=r*e,a=r*l;for(let r=0;r<e;r++)n[r+t+a+o]=i[r+h+s]}}t+=e}else{let e=i._s[1];for(let r=0;r<a;r++){let s=r*l*e,o=r*l*h;for(let r=0;r<e;r++){let e=r*l,h=(r+t)*l;for(let t=0;t<l;t++)n[t+h+o]=i[t+e+s]}}t+=e}}}return n})})}o("which",function(t){this._data_cube||w(this),t=n.single(t);const e=this.length,r=new Array(e);let s=0;if(void 0!==t){n.func(t);for(let n=0;n<e;n++)t(this[n],n,this)&&(r[s++]=n)}else for(let t=0;t<e;t++)this[t]&&(r[s++]=t);return r.length=s,r}),o("toMatrix",function(){this._data_cube||w(this);const t=this.length;if(0===t)throw Error("non-empty array/cube expected");const e=Object.keys(this[0]),r=e.length,n=[t,r].cube();n.$key(1,e);for(let s=0;s<t;s++){let i=this[s];for(let o=0;o<r;o++)n[s+t*o]=i[e[o]]}return n});{const e=t=>c(t).toCube();e.cube=((t,e)=>c(t).cube(e)),e.rand=((t,e)=>c(t).rand(e)),e.normal=((t,e,r)=>c(t).normal(e,r)),e.copy=((t,e)=>c(t).copy(e)),o("_helper",r),t.exports=e}}})});
